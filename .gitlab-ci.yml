# SPDX-FileCopyrightText: 2026 Mattia Egloff <mattia.egloff@pm.me>
#
# SPDX-License-Identifier: GPL-3.0-or-later

# GitLab CI for vauchi-cli
#
# Command-line interface
#
# Performance optimizations:
#   - Self-hosted runners: sccache, persistent caches, load-balanced
#   - Change-based rules: Jobs run only when relevant files change
#   - Timeouts: Prevent runaway jobs from blocking runners
#   - Read-only cache for lint jobs
#
# Pipeline strategy:
#   - MR: Validation on relevant file changes
#   - Upstream trigger: Verify compatibility when core merges to main
#
# Uses shared templates from vauchi/scripts for consistency.

# Include shared templates
include:
  - project: 'vauchi/scripts'
    ref: main
    file:
      - '/ci-templates/rust-base.yml'
      - '/ci-templates/security.yml'
      - '/ci-templates/mr-rules.yml'
      - '/ci-templates/downstream.yml'
      - '/ci-templates/reuse.yml'
      - '/ci-templates/test-quality.yml'

stages:
  - lint
  - test
  - mutation
  - security
  - verify

# ============================================================
# Lint Stage â€” Preflight Gate (runs on Rust code changes)
# ============================================================
# Cheapest checks run first. Test + security jobs wait for these
# to pass before starting (PI-13 fail-fast DAG).

lint:format:
  extends: [.rust-runner-nocache, .validation-rust, .timeout-quick]
  stage: lint
  needs: []
  script:
    - cargo fmt --all -- --check

lint:clippy:
  extends: [.rust-runner-readonly, .validation-rust, .timeout-quick]
  stage: lint
  needs: []
  script:
    - cargo clippy --all-targets -- -D warnings

# ============================================================
# Test Stage (runs on Rust code changes, gated by lint)
# ============================================================

# MR: fast nextest (no coverage overhead)
test:
  extends: [.rust-runner, .validation-rust, .timeout-quick]
  stage: test
  needs:
    - job: lint:format
      optional: true
    - job: lint:clippy
      optional: true
  script:
    - cargo nextest run --all-targets --no-default-features

# Main: full coverage with llvm-cov
coverage:
  extends: [.rust-runner, .timeout-standard]
  stage: test
  needs:
    - job: lint:format
      optional: true
    - job: lint:clippy
      optional: true
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
  before_script:
    - !reference [.self-hosted, before_script]
    - !reference [.git-credentials, before_script]
  script:
    - cargo llvm-cov nextest --all-targets --no-default-features --lcov --output-path lcov.info
    - cargo llvm-cov report --cobertura --output-path cobertura.xml
    - cargo llvm-cov report
  coverage: '/Total:\s+(\d+(?:\.\d+)?%)/'
  artifacts:
    reports:
      coverage_report:
        coverage_format: cobertura
        path: cobertura.xml
    paths:
      - lcov.info
      - cobertura.xml
    expire_in: 1 week

# ============================================================
# Mutation Stage (PI-02)
# ============================================================

# Nightly full mutation testing (scheduled pipeline)
mutation:nightly:
  extends: [.rust-runner, .timeout-extended]
  stage: mutation
  needs: []
  rules:
    - if: $CI_PIPELINE_SOURCE == "schedule"
  allow_failure: true
  script:
    - command -v cargo-mutants >/dev/null 2>&1 || cargo binstall cargo-mutants --no-confirm 2>/dev/null || cargo install cargo-mutants --locked || true
    - |
      MUTANTS_OUT="target/mutants"
      cargo mutants --no-default-features --timeout 60 --output "$MUTANTS_OUT" &
      MUTANTS_PID=$!
      trap 'kill $MUTANTS_PID 2>/dev/null; wait $MUTANTS_PID 2>/dev/null' EXIT

      G='\033[32m'; R='\033[31m'; Y='\033[33m'; D='\033[2m'
      B='\033[1m'; C='\033[36m'; Z='\033[0m'

      count() { if [ -f "$1" ]; then wc -l < "$1" | tr -d ' '; else echo 0; fi; }
      color_type() {
        case "$1" in
          caught)  printf "${G}caught${Z}" ;;
          missed)  printf "${R}MISSED${Z}" ;;
          timeout) printf "${Y}timeout${Z}" ;;
          *)       printf "${D}unviable${Z}" ;;
        esac
      }
      last_mutant() {
        local f
        f=$(ls -t "$MUTANTS_OUT"/caught.txt "$MUTANTS_OUT"/missed.txt \
              "$MUTANTS_OUT"/timeout.txt "$MUTANTS_OUT"/unviable.txt 2>/dev/null | head -1)
        if [ -n "$f" ]; then
          printf "  \xe2\x94\x94 %s \xe2\x80\x94 %b\n" "$(tail -1 "$f")" "$(color_type "$(basename "$f" .txt)")"
        fi
      }

      while [ ! -f "$MUTANTS_OUT/mutants.json" ] && kill -0 "$MUTANTS_PID" 2>/dev/null; do
        sleep 10
      done
      if ! kill -0 "$MUTANTS_PID" 2>/dev/null; then
        wait "$MUTANTS_PID"; exit $?
      fi

      TOTAL=$(python3 -c "import json; print(len(json.load(open('$MUTANTS_OUT/mutants.json'))))" 2>/dev/null || echo "0")

      printf "\033[0Ksection_start:%s:baseline[collapsed=true]\r\033[0K" "$(date +%s)"
      printf "${B}${C}Baseline: compiling and running unmutated tests${Z}\n"

      SECONDS=0; BASELINE_OPEN=true; TESTING_OPEN=false

      while kill -0 "$MUTANTS_PID" 2>/dev/null; do
        sleep 30
        c=$(count "$MUTANTS_OUT/caught.txt"); m=$(count "$MUTANTS_OUT/missed.txt")
        t=$(count "$MUTANTS_OUT/timeout.txt"); u=$(count "$MUTANTS_OUT/unviable.txt")
        d=$((c + m + t + u))

        if [ "$d" -eq 0 ]; then
          printf "Waiting... (%dm elapsed)\n" "$((SECONDS / 60))"
          continue
        fi

        if $BASELINE_OPEN; then
          printf "\033[0Ksection_end:%s:baseline\r\033[0K" "$(date +%s)"
          printf "\033[0Ksection_start:%s:testing\r\033[0K" "$(date +%s)"
          printf "${B}${C}Testing %d mutants${Z}\n" "$TOTAL"
          BASELINE_OPEN=false; TESTING_OPEN=true
        fi

        pct=$((d * 100 / TOTAL))
        eta=""
        if [ "$SECONDS" -gt 0 ] && [ "$d" -gt 0 ]; then
          rem=$(( (TOTAL - d) * SECONDS / d / 60 ))
          eta="  ${D}(~${rem}m remaining)${Z}"
        fi

        printf "[%3d/%d %2d%%] ${G}%d caught${Z}, ${R}%d missed${Z}, ${Y}%d timeout${Z}, ${D}%d unviable${Z}%b\n" \
          "$d" "$TOTAL" "$pct" "$c" "$m" "$t" "$u" "$eta"
        last_mutant
      done

      $BASELINE_OPEN && printf "\033[0Ksection_end:%s:baseline\r\033[0K" "$(date +%s)"
      $TESTING_OPEN && printf "\033[0Ksection_end:%s:testing\r\033[0K" "$(date +%s)"

      wait "$MUTANTS_PID"
      EXIT_CODE=$?

      c=$(count "$MUTANTS_OUT/caught.txt"); m=$(count "$MUTANTS_OUT/missed.txt")
      t=$(count "$MUTANTS_OUT/timeout.txt"); u=$(count "$MUTANTS_OUT/unviable.txt")
      d=$((c + m + t + u))
      [ "$TOTAL" -gt 0 ] 2>/dev/null && cpct=$((c * 100 / TOTAL)) || cpct=0

      echo ""
      printf "${B}=== Mutation Testing Summary ===${Z}\n"
      printf "  Total:    %d / %d\n" "$d" "$TOTAL"
      printf "  Caught:   ${G}%d (%d%%)${Z}\n" "$c" "$cpct"
      printf "  Missed:   ${R}%d${Z}\n" "$m"
      printf "  Timeout:  ${Y}%d${Z}\n" "$t"
      printf "  Unviable: ${D}%d${Z}\n" "$u"
      if [ -s "$MUTANTS_OUT/missed.txt" ]; then
        echo ""
        printf "${R}${B}Missed mutants:${Z}\n"
        while IFS= read -r line; do printf "  ${R}%s${Z}\n" "$line"; done < "$MUTANTS_OUT/missed.txt"
      fi

      exit "$EXIT_CODE"
  artifacts:
    paths:
      - target/mutants/
    expire_in: 1 week

# Per-MR incremental mutation testing (advisory, runs after tests pass)
mutation:incremental:
  extends: [.rust-runner, .timeout-extended]
  stage: mutation
  needs:
    - job: test
      optional: true
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
  allow_failure: true
  variables:
    GIT_DEPTH: "100"
  script:
    - command -v cargo-mutants >/dev/null 2>&1 || cargo binstall cargo-mutants --no-confirm 2>/dev/null || cargo install cargo-mutants --locked || true
    - git fetch origin "$CI_MERGE_REQUEST_TARGET_BRANCH_NAME" --depth=100
    - git diff "origin/$CI_MERGE_REQUEST_TARGET_BRANCH_NAME"...HEAD > mr.diff
    - |
      MUTANTS_OUT="mutants.out"
      cargo mutants --no-default-features --in-diff mr.diff --timeout 120 --mutant-limit 50 --baseline skip &
      MUTANTS_PID=$!
      trap 'kill $MUTANTS_PID 2>/dev/null; wait $MUTANTS_PID 2>/dev/null' EXIT

      G='\033[32m'; R='\033[31m'; Y='\033[33m'; D='\033[2m'
      B='\033[1m'; C='\033[36m'; Z='\033[0m'

      count() { if [ -f "$1" ]; then wc -l < "$1" | tr -d ' '; else echo 0; fi; }
      color_type() {
        case "$1" in
          caught)  printf "${G}caught${Z}" ;;
          missed)  printf "${R}MISSED${Z}" ;;
          timeout) printf "${Y}timeout${Z}" ;;
          *)       printf "${D}unviable${Z}" ;;
        esac
      }
      last_mutant() {
        local f
        f=$(ls -t "$MUTANTS_OUT"/caught.txt "$MUTANTS_OUT"/missed.txt \
              "$MUTANTS_OUT"/timeout.txt "$MUTANTS_OUT"/unviable.txt 2>/dev/null | head -1)
        if [ -n "$f" ]; then
          printf "  \xe2\x94\x94 %s \xe2\x80\x94 %b\n" "$(tail -1 "$f")" "$(color_type "$(basename "$f" .txt)")"
        fi
      }

      while [ ! -f "$MUTANTS_OUT/mutants.json" ] && kill -0 "$MUTANTS_PID" 2>/dev/null; do
        sleep 10
      done
      if ! kill -0 "$MUTANTS_PID" 2>/dev/null; then
        wait "$MUTANTS_PID"; exit $?
      fi

      TOTAL=$(python3 -c "import json; print(len(json.load(open('$MUTANTS_OUT/mutants.json'))))" 2>/dev/null || echo "0")

      printf "\033[0Ksection_start:%s:baseline[collapsed=true]\r\033[0K" "$(date +%s)"
      printf "${B}${C}Baseline: compiling and running unmutated tests${Z}\n"

      SECONDS=0; BASELINE_OPEN=true; TESTING_OPEN=false

      while kill -0 "$MUTANTS_PID" 2>/dev/null; do
        sleep 30
        c=$(count "$MUTANTS_OUT/caught.txt"); m=$(count "$MUTANTS_OUT/missed.txt")
        t=$(count "$MUTANTS_OUT/timeout.txt"); u=$(count "$MUTANTS_OUT/unviable.txt")
        d=$((c + m + t + u))

        if [ "$d" -eq 0 ]; then
          printf "Waiting... (%dm elapsed)\n" "$((SECONDS / 60))"
          continue
        fi

        if $BASELINE_OPEN; then
          printf "\033[0Ksection_end:%s:baseline\r\033[0K" "$(date +%s)"
          printf "\033[0Ksection_start:%s:testing\r\033[0K" "$(date +%s)"
          printf "${B}${C}Testing %d mutants${Z}\n" "$TOTAL"
          BASELINE_OPEN=false; TESTING_OPEN=true
        fi

        pct=$((d * 100 / TOTAL))
        eta=""
        if [ "$SECONDS" -gt 0 ] && [ "$d" -gt 0 ]; then
          rem=$(( (TOTAL - d) * SECONDS / d / 60 ))
          eta="  ${D}(~${rem}m remaining)${Z}"
        fi

        printf "[%3d/%d %2d%%] ${G}%d caught${Z}, ${R}%d missed${Z}, ${Y}%d timeout${Z}, ${D}%d unviable${Z}%b\n" \
          "$d" "$TOTAL" "$pct" "$c" "$m" "$t" "$u" "$eta"
        last_mutant
      done

      $BASELINE_OPEN && printf "\033[0Ksection_end:%s:baseline\r\033[0K" "$(date +%s)"
      $TESTING_OPEN && printf "\033[0Ksection_end:%s:testing\r\033[0K" "$(date +%s)"

      wait "$MUTANTS_PID"
      EXIT_CODE=$?

      c=$(count "$MUTANTS_OUT/caught.txt"); m=$(count "$MUTANTS_OUT/missed.txt")
      t=$(count "$MUTANTS_OUT/timeout.txt"); u=$(count "$MUTANTS_OUT/unviable.txt")
      d=$((c + m + t + u))
      [ "$TOTAL" -gt 0 ] 2>/dev/null && cpct=$((c * 100 / TOTAL)) || cpct=0

      echo ""
      printf "${B}=== Mutation Testing Summary ===${Z}\n"
      printf "  Total:    %d / %d\n" "$d" "$TOTAL"
      printf "  Caught:   ${G}%d (%d%%)${Z}\n" "$c" "$cpct"
      printf "  Missed:   ${R}%d${Z}\n" "$m"
      printf "  Timeout:  ${Y}%d${Z}\n" "$t"
      printf "  Unviable: ${D}%d${Z}\n" "$u"
      if [ -s "$MUTANTS_OUT/missed.txt" ]; then
        echo ""
        printf "${R}${B}Missed mutants:${Z}\n"
        while IFS= read -r line; do printf "  ${R}%s${Z}\n" "$line"; done < "$MUTANTS_OUT/missed.txt"
      fi

      exit "$EXIT_CODE"
  artifacts:
    paths:
      - mutants.out/
    expire_in: 1 week
    when: always

# ============================================================
# Security Stage (runs on dependency changes, gated by lint, parallel with test)
# ============================================================

security:audit:
  extends: [.rust-runner-readonly, .validation-deps, .timeout-quick]
  stage: security
  needs:
    - job: lint:format
      optional: true
    - job: lint:clippy
      optional: true
  script:
    - cargo audit

# Full cargo-deny check: advisories, licenses, bans, sources
security:deny:
  extends: [.rust-runner-readonly, .timeout-quick]
  stage: security
  needs:
    - job: lint:format
      optional: true
    - job: lint:clippy
      optional: true
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_PIPELINE_SOURCE == "schedule"
  script:
    - cargo deny check

# ============================================================
# Verify Stage (upstream trigger only)
# ============================================================
# Runs when core merges to main and triggers this repo via
# verify:downstream-rust. Verifies this repo builds and tests
# pass against the updated vauchi-core.

verify:upstream-compat:
  extends: [.rust-runner, .verify-on-upstream, .timeout-standard]
  stage: verify
  needs: []
  script:
    - cargo nextest run --all-targets --no-default-features
